<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Speakfluentâ€”â€”AIè®©è‹±è¯­å¯¹è¯æ›´æµç•…</title>
  <style>
    :root{
      --bg:#0f172a; --soft:#0b1220; --text:#e5e7eb; --muted:#94a3b8;
      --accent:#38bdf8; --ring:#22d3ee; --shadow:0 6px 24px rgba(0,0,0,.25);
      --sb-thumb:#274470; --sb-thumb-hover:#3a6aa3;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b1020,var(--bg));color:var(--text);font:14px/1.5 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","Helvetica Neue",Arial,"Noto Sans CJK SC",sans-serif;overflow:hidden;}
    .app{display:grid;grid-template-columns:300px 1fr;height:100vh;width:100vw;}
    .sidebar{background:linear-gradient(180deg,var(--soft),#0b0f1a);border-right:1px solid #1f2a44;display:flex;flex-direction:column;gap:12px;padding:16px;overflow:hidden;}
    .brand{display:flex;align-items:center;gap:10px;padding:6px 8px;}
    .brand .logo{width:28px;height:28px;border-radius:8px;display:grid;place-items:center;background:linear-gradient(135deg,#22d3ee,#0ea5e9);color:#001018;font-weight:800;box-shadow:var(--shadow);}
    .title{font-weight:700}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap}
    .btn{background:#0f172a;border:1px solid #1f2a44;border-radius:10px;color:var(--text);padding:8px 10px;cursor:pointer;transition:.15s;user-select:none}
    .btn:hover{border-color:#274470;transform:translateY(-1px)}
    .btn.primary{background:linear-gradient(135deg,#0ea5e9,#22d3ee);color:#06121b;font-weight:700}
    .btn.ghost{background:transparent}
    .btn.danger{border-color:#4b1d1d;color:#fecaca}
    .btn:disabled{background:#1f2937;color:#6b7280;cursor:not-allowed}
    .search input{width:100%;background:#0f172a;border:1px solid #1f2a44;color:var(--text);padding:10px 12px;border-radius:10px;outline:none;transition:.15s}
    .search input:focus{border-color:#274470;box-shadow:0 0 0 3px #0ea5e933}
    .history{flex:1;margin-top:6px;padding-right:2px;overflow-y:auto;overflow-x:hidden;scrollbar-gutter:stable both-edges;-webkit-overflow-scrolling:touch;position:relative;z-index:0;}
    .session{display:flex;align-items:center;gap:8px;padding:10px;border-radius:10px;cursor:pointer;transition:.12s;border:1px solid transparent;}
    .session:hover{background:#0f172a;border-color:#1f2a44}
    .session.active{background:#0e2533;border-color:#1a4f63}
    .session .name{flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .session .time{color:var(--muted);font-size:12px}
    .main{display:grid;grid-template-rows:auto 1fr auto;height:100vh;overflow:hidden;position:relative;}
    .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:14px 18px;border-bottom:1px solid #16223b;background:rgba(0,0,0,.15);position:relative;z-index:2;}
    .conv-title{display:flex;align-items:center;gap:10px;font-weight:700}
    .conv-title input{background:transparent;border:1px dashed transparent;color:var(--text);padding:4px 6px;border-radius:8px;font-weight:700;font-size:16px;width:min(46vw,520px)}
    .conv-title input:focus{border-color:#274470;outline:none;background:#0b1624}
    .voice-panel{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end;}
    .voice-panel .field{display:flex;align-items:center;gap:6px}
    select,input[type="range"]{background:#0f172a;color:var(--text);border:1px solid #1f2a44;border-radius:10px;padding:8px;outline:none;transition:.15s}
    select:focus,input[type="range"]:focus{box-shadow:0 0 0 3px #0ea5e933;border-color:#274470}
    .chat{overflow-y:auto;overflow-x:hidden;padding:20px 24px 24px;scroll-behavior:smooth;background:radial-gradient(600px 200px at 30% -10%,#08334440,transparent);scrollbar-gutter:stable both-edges;-webkit-overflow-scrolling:touch;position:relative;z-index:1;}
    .msg{display:grid;grid-template-columns:36px 1fr;gap:12px;margin:8px 0;align-items:flex-start}
    .avatar{width:36px;height:36px;border-radius:10px;display:grid;place-items:center;font-weight:800}
    .avatar.user{background:#334155;color:#e2e8f0}
    .avatar.ai{background:linear-gradient(135deg,#0ea5e9,#22d3ee);color:#04121a}
    .bubble{background:#1f2937;border:1px solid #1f2a44;border-radius:14px;padding:12px 14px;box-shadow:var(--shadow)}
    .bubble.ai{background:#0ea5e91a;border-color:#184a5c}
    .bubble .meta{font-size:12px;color:var(--muted);margin-bottom:6px}
    .bubble .tools{display:flex;gap:8px;opacity:.9;margin-top:6px}
    .bubble .tools button{background:transparent;border:1px solid #1f2a44;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer}
    .composer{display:grid;grid-template-columns:1fr auto auto;gap:10px;padding:14px 18px;border-top:1px solid #16223b;background:linear-gradient(180deg,rgba(0,0,0,.15),rgba(0,0,0,.25));position:relative;z-index:2;}
    .input-wrap{display:flex;align-items:center;background:#0f172a;border:1px solid #1f2a44;border-radius:14px;padding:8px 10px;box-shadow:var(--shadow)}
    textarea{flex:1;resize:none;background:transparent;border:none;color:#e5e7eb;outline:none;font:inherit;padding:6px 8px;height:56px}
    .send{min-width:120px;background:linear-gradient(135deg,#0ea5e9,#22d3ee);color:#03131c;font-weight:800;border:none;border-radius:12px;padding:14px 18px;cursor:pointer;box-shadow:var(--shadow)}
    .muted{color:var(--muted)}
    .empty{margin:40px auto;max-width:680px;text-align:center;color:var(--muted);padding:24px;background:#0f172a;border:1px dashed #223155;border-radius:16px}
    @media (max-width:980px){.app{grid-template-columns:1fr}.sidebar{display:none}.voice-panel{justify-content:flex-start}}
    *{scrollbar-width:thin;scrollbar-color:var(--sb-thumb) transparent;}
    ::-webkit-scrollbar{width:10px;height:10px}
    ::-webkit-scrollbar-track{background:transparent}
    ::-webkit-scrollbar-thumb{background:var(--sb-thumb);border-radius:8px;border:2px solid transparent;background-clip:content-box}
    ::-webkit-scrollbar-thumb:hover{background:var(--sb-thumb-hover)}
  </style>
</head>
<body>
  <!-- ç™»å½•å¼¹çª— -->
  <div id="loginModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.5);z-index:1000">
    <div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#0f172a;padding:20px;border-radius:10px">
      <h3>ç™»å½•</h3>
      <input id="loginUsername" placeholder="ç”¨æˆ·å" style="margin:5px;padding:5px"><br>
      <input id="password" type="password" placeholder="å¯†ç " style="margin:5px;padding:5px"><br>
      <button id="loginBtn" onclick="login()">ç™»å½•</button>
      <button id="registerBtn" onclick="register()">æ³¨å†Œ</button>
      <button onclick="closeModal()">å…³é—­</button>
    </div>
  </div>

  <div class="app" id="app">
    <aside class="sidebar" id="sidebar">
      <div class="brand">
        <div class="logo">SF</div>
        <div>
          <div class="title">Speakfluentâ€”â€”AIè®©è‹±è¯­å¯¹è¯æ›´æµç•…</div>
          <div class="muted">å½“å‰ç”¨æˆ·: <span id="username">æœªç™»å½•</span></div>
          <div class="muted">å†å²å¯ç»­èŠ Â· æ¨¡å—ç‹¬ç«‹æ»šåŠ¨</div>
        </div>
      </div>
      <div class="toolbar">
        <button class="btn primary" id="btnNew">æ–°å»ºå¯¹è¯</button>
        <button class="btn ghost" id="btnExport">å¯¼å‡ºå…¨éƒ¨</button>
        <button class="btn danger" id="btnClearAll">æ¸…ç©º</button>
        <button class="btn ghost" id="btnLogout">æ³¨é”€</button>
      </div>
      <div class="search" style="margin-top:6px">
        <input id="searchInput" placeholder="æœç´¢å†å²ä¼šè¯â€¦" />
      </div>
      <div class="history" id="history"></div>
      <div class="muted" style="font-size:12px">æ•°æ®ä¿å­˜åœ¨ <code>localStorage</code>ã€‚</div>
    </aside>

    <main class="main">
      <div class="topbar">
        <div class="conv-title">
          <span class="muted">ä¼šè¯æ ‡é¢˜ï¼š</span>
          <input id="convTitle" value="æ–°çš„å¯¹è¯" />
        </div>
        <div class="voice-panel">
          <label title="å¼€å¯åï¼ŒAI å›å¤å°†è‡ªåŠ¨æ’­æŠ¥" style="display:flex;gap:8px;align-items:center">
            <input type="checkbox" id="toggleSpeak" checked>
            <span>è‡ªåŠ¨æ’­æŠ¥</span>
          </label>
          <div class="field"><span class="muted">å‘éŸ³äºº</span>
            <select id="voiceSelect"></select>
            <button class="btn ghost" id="btnReloadVoices">åˆ·æ–°å£°éŸ³</button>
          </div>
          <div class="field"><span class="muted">è¯­é€Ÿ</span><input id="rate" type="range" min="0.5" max="2" step="0.05" value="1"></div>
          <div class="field"><span class="muted">éŸ³è°ƒ</span><input id="pitch" type="range" min="0" max="2" step="0.05" value="1"></div>
          <div class="field"><span class="muted">éŸ³é‡</span><input id="volume" type="range" min="0" max="1" step="0.05" value="1"></div>
          <button class="btn ghost" id="btnStopSpeak">åœæ­¢</button>
          <button class="btn ghost" id="btnMute">é™éŸ³</button>
        </div>
      </div>
      <div class="chat" id="chat">
        <div class="empty">ğŸ‘‹ å‘æ¶ˆæ¯è¯•è¯•ã€‚è¿™é‡Œæ˜¯<b>èŠå¤©åŒºçš„ç‹¬ç«‹æ»šåŠ¨æ¡</b>ã€‚</div>
      </div>
      <div class="composer">
        <div class="input-wrap"><textarea id="input" placeholder="è¾“å…¥å†…å®¹ï¼ŒShift+Enter æ¢è¡Œâ€¦"></textarea></div>
        <button class="send" id="btnSend">å‘é€</button>
        <button class="send" id="spkSend">
          <img src="/static/images/OIP-C.webp" alt="ç‚¹å‡»è¯´è¯" width="50px">
        </button>
      </div>
    </main>
  </div>
  <script>
    /* ================= é…ç½® ================= */
    const API_ENDPOINT = "http://localhost:8000";

    /* ================= çŠ¶æ€ ================= */
    const storeKey = "ai_tutor_sessions_v1";
    const state = {
      sessions: [],
      currentId: null,
      speakingMuted: false,
      token: localStorage.getItem('token') || null,
      username: localStorage.getItem('username') || null,
      isLoggingIn: false,
      isSending: false // é˜²æ­¢é‡å¤å‘é€
    };

    /* ================= å·¥å…· ================= */
    const $ = (s, r = document) => r.querySelector(s);
    const $$ = (s, r = document) => Array.from(r.querySelectorAll(s));
    const now = () => Date.now();
    const fmt = t => new Date(t).toLocaleString();
    const save = () => localStorage.setItem(storeKey, JSON.stringify(state.sessions));
    const escapeHTML = (str = "") => str.replace(/&/g, "&amp;").replace(/</g, "&gt;").replace(/</g, "&lt;");
    const toast = (msg, dur = 1600) => {
      const t = document.createElement("div");
      t.textContent = msg;
      Object.assign(t.style, { position: "fixed", left: "50%", top: "10%", transform: "translateX(-50%)", background: "#0b1624", color: "#e5e7eb", border: "1px solid #1f2a44", padding: "10px 14px", borderRadius: "10px", zIndex: 9999, boxShadow: "var(--shadow)" });
      document.body.appendChild(t);
      setTimeout(() => t.remove(), dur);
    };

    /* ================= Token éªŒè¯ ================= */
    async function validateToken(token) {
      try {
        const res = await fetch(`${API_ENDPOINT}/validate-token`, {
          method: "GET",
          headers: { "Authorization": `Bearer ${token}` }
        });
        return res.ok;
      } catch (err) {
        console.error("Token validation failed:", err.message);
        return false;
      }
    }

    /* ================= ä¼šè¯éªŒè¯ ================= */
    async function validateConversation(convId) {
      try {
        const res = await fetch(`${API_ENDPOINT}/conversations/${convId}`, {
          method: "GET",
          headers: { "Authorization": `Bearer ${state.token}` }
        });
        return res.ok;
      } catch (err) {
        console.error("Conversation validation failed:", err.message);
        return false;
      }
    }

    /* ================= åŒæ­¥ä¼šè¯ ================= */
    async function syncConversations() {
      try {
        const res = await fetch(`${API_ENDPOINT}/conversations`, {
          method: "GET",
          headers: { "Authorization": `Bearer ${state.token}` }
        });
        if (!res.ok) {
          if (res.status === 401) {
            localStorage.removeItem('token');
            localStorage.removeItem('username');
            state.token = null;
            state.username = null;
            $("#username").textContent = "æœªç™»å½•";
            showModal();
            throw new Error("ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•");
          }
          throw new Error("è·å–ä¼šè¯åˆ—è¡¨å¤±è´¥ " + res.status);
        }
        const remoteConvs = await res.json();
        state.sessions = state.sessions.filter(s => remoteConvs.some(rc => rc.id === s.id));
        remoteConvs.forEach(rc => {
          if (!state.sessions.some(s => s.id === rc.id)) {
            state.sessions.push({
              id: rc.id,
              name: rc.title,
              createdAt: now(),
              updatedAt: now(),
              messages: rc.history ? JSON.parse(rc.history) : []
            });
          }
        });
        save();
        if (!state.sessions.some(s => s.id === state.currentId)) {
          state.currentId = null;
        }
      } catch (err) {
        console.error("Sync conversations failed:", err.message);
        toast("åŒæ­¥ä¼šè¯å¤±è´¥: " + err.message);
      }
    }

    /* ================= è¿œç¨‹åˆ›å»ºä¼šè¯ ================= */
    const createRemoteSession = async (title = "æ–°çš„å¯¹è¯") => {
      const res = await fetch(`${API_ENDPOINT}/conversations`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${state.token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ title })
      });
      if (!res.ok) {
        if (res.status === 401) {
          localStorage.removeItem('token');
          localStorage.removeItem('username');
          state.token = null;
          state.username = null;
          $("#username").textContent = "æœªç™»å½•";
          showModal();
          throw new Error("ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•");
        }
        throw new Error("åˆ›å»ºä¼šè¯å¤±è´¥ " + res.status);
      }
      return await res.json();
    };

    /* ================= æ•°æ®&æ¸²æŸ“ ================= */
    const findSession = id => state.sessions.find(s => s.id === id);
    const selectSession = id => {
      state.currentId = id;
      renderHistory();
      renderChat();
      const s = findSession(id);
      $("#convTitle").value = s?.name || "æ–°çš„å¯¹è¯";
      document.title = s?.name ? `${s.name} Â· AI å¯¼å¸ˆ` : "AI å¯¼å¸ˆ";
    };
    const renameCurrent = (title) => {
      const s = findSession(state.currentId);
      if (!s) return;
      s.name = title.trim() || "æœªå‘½åå¯¹è¯";
      s.updatedAt = now();
      save();
      renderHistory();
    };
    const deleteSession = id => {
      const i = state.sessions.findIndex(s => s.id === id);
      if (i >= 0) {
        state.sessions.splice(i, 1);
        save();
        if (state.currentId === id) {
          const s = state.sessions[0] || { id: "s_fallback", name: "æ–°çš„å¯¹è¯", createdAt: now(), updatedAt: now(), messages: [] };
          selectSession(s.id);
        } else {
          renderHistory();
        }
      }
    };

    const renderHistory = () => {
      const box = $("#history");
      const q = ($("#searchInput").value || "").toLowerCase();
      box.innerHTML = "";
      state.sessions.filter(s => !q || s.name.toLowerCase().includes(q))
        .sort((a, b) => b.updatedAt - a.updatedAt)
        .forEach(s => {
          const el = document.createElement("div");
          el.className = "session" + (state.currentId === s.id ? " active" : "");
          el.innerHTML = `<div class="name" title="${s.name}">${s.name}</div><div class="time">${new Date(s.updatedAt).toLocaleDateString()}</div>`;
          el.addEventListener("click", () => selectSession(s.id));
          el.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            if (confirm(`åˆ é™¤ã€Š${s.name}ã€‹ï¼Ÿ`)) deleteSession(s.id);
          });
          box.appendChild(el);
        });
    };

    const msgHTML = (m, i) => {
      const isAI = m.role === "assistant";
      const role = isAI ? "ai" : (m.role === "error" ? "ai" : "user");
      const meta = `${isAI ? "AI" : (m.role === "error" ? "ç³»ç»Ÿ" : "ä½ ")} Â· ${fmt(m.time)}`;
      const tools = isAI ? `<div class="tools">
        <button data-act="speak" data-idx="${i}">æœ—è¯»</button>
        <button data-act="copy"  data-idx="${i}">å¤åˆ¶</button>
        <button data-act="regen" data-idx="${i}">é‡è¯•</button>
      </div>` : "";
      return `<div class="msg">
        <div class="avatar ${role}">${isAI ? "AI" : "ä½ "}</div>
        <div class="bubble ${isAI ? "ai" : ""}">
          <div class="meta">${meta}</div>
          <div class="content">${escapeHTML(m.content).replace(/\n/g, "<br/>")}</div>
          ${tools}
        </div>
      </div>`;
    };

    const renderChat = () => {
      const s = findSession(state.currentId);
      const box = $("#chat");
      if (!s || !s.messages.length) {
        box.innerHTML = `<div class="empty">æš‚æ— æ¶ˆæ¯ã€‚å¼€å§‹èŠå¤©å§ï¼</div>`;
        return;
      }
      box.innerHTML = s.messages.map((m, i) => msgHTML(m, i)).join("");
      box.querySelectorAll(".tools button").forEach(btn => {
        btn.addEventListener("click", (e) => {
          const idx = +e.currentTarget.dataset.idx;
          const act = e.currentTarget.dataset.act;
          if (act === "copy") {
            navigator.clipboard.writeText(s.messages[idx].content).then(() => toast("å·²å¤åˆ¶"));
          }
          if (act === "regen") {
            const k = findPrevUserIndex(s.messages, idx);
            if (k >= 0) send(s.messages[k].content, true);
          }
          if (act === "speak") playAudioFromServer(s.messages[idx].audio);
        });
      });
      box.scrollTop = box.scrollHeight + 400;
    };

    const findPrevUserIndex = (msgs, from) => {
      for (let i = from; i >= 0; i--) if (msgs[i].role === "user") return i;
      return -1;
    };

    /* ================= å‘é€æ¶ˆæ¯ ================= */
    const addMessage = (role, content, audio = null) => {
      const s = findSession(state.currentId);
      if (!s) return;
      s.messages.push({ role, content, time: now(), audio });
      s.updatedAt = now();
      save();
      renderChat();
    };

    const send = async (text, isRetry = false) => {
      if (state.isSending) {
          toast("æ­£åœ¨å‘é€ï¼Œè¯·ç¨å€™");
          return;
      }
      state.isSending = true;
      $("#btnSend").disabled = true;
      $("#spkSend").disabled = true;

      const content = (text || $("#input").value || "").trim();
      if (!content && !$("#spkSend").files?.length) {
          console.error("No content or audio provided");
          toast("è¯·è¾“å…¥æ–‡æœ¬æˆ–ä¸Šä¼ éŸ³é¢‘");
          state.isSending = false;
          $("#btnSend").disabled = false;
          $("#spkSend").disabled = false;
          return;
      }
      if (!state.token) {
          console.error("No token available, please login");
          toast("è¯·å…ˆç™»å½•");
          showModal();
          state.isSending = false;
          $("#btnSend").disabled = false;
          $("#spkSend").disabled = false;
          return;
      }

      if (!(await validateConversation(state.currentId))) {
          try {
              const remote = await createRemoteSession("æ–°çš„å¯¹è¯");
              state.sessions = state.sessions.filter(s => s.id !== state.currentId);
              const newSession = { id: remote.id, name: remote.title, createdAt: now(), updatedAt: now(), messages: [] };
              state.sessions.unshift(newSession);
              state.currentId = newSession.id;
              save();
              selectSession(newSession.id);
              toast("åŸä¼šè¯ä¸å­˜åœ¨ï¼Œå·²åˆ›å»ºæ–°ä¼šè¯");
          } catch (e) {
              toast("åˆ›å»ºæ–°ä¼šè¯å¤±è´¥: " + e.message);
              state.isSending = false;
              $("#btnSend").disabled = false;
              $("#spkSend").disabled = false;
              return;
          }
      }

      const s = findSession(state.currentId);
      if (!s) {
          console.error("No session found for currentId:", state.currentId);
          toast("æœªæ‰¾åˆ°ä¼šè¯ï¼Œè¯·åˆ›å»ºæ–°ä¼šè¯");
          state.isSending = false;
          $("#btnSend").disabled = false;
          $("#spkSend").disabled = false;
          return;
      }
      if (s.messages.filter(m => m.role === "user").length === 0) renameCurrent(content.slice(0, 20));
      if (!isRetry) addMessage("user", content);

      const tempId = "t_" + Math.random().toString(36).slice(2);
      s.messages.push({ role: "assistant", content: "æ­£åœ¨æ€è€ƒâ€¦", time: now(), tempId });
      save();
      renderChat();
      $("#input").value = "";
      $("#input").focus();

      try {
          const formData = new FormData();
          if ($("#spkSend").files?.[0]) {
              formData.append("audio", $("#spkSend").files[0]);
              console.log("Sending audio:", $("#spkSend").files[0].name, $("#spkSend").files[0].type);
          } else {
              formData.append("text", content);
              console.log("Sending text:", content);
          }

          console.log("Token:", state.token);
          console.log("Conversation ID:", s.id);
          const res = await fetch(`${API_ENDPOINT}/conversations/${String(s.id)}/chat`, {
              method: "POST",
              headers: { "Authorization": `Bearer ${state.token}` },
              body: formData
          });
          if (!res.ok) {
              if (res.status === 401) {
                  localStorage.removeItem('token');
                  localStorage.removeItem('username');
                  state.token = null;
                  state.username = null;
                  $("#username").textContent = "æœªç™»å½•";
                  showModal();
                  throw new Error("ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•");
              }
              if (res.status === 404) {
                  try {
                      const remote = await createRemoteSession("æ–°çš„å¯¹è¯");
                      state.sessions = state.sessions.filter(s => s.id !== state.currentId);
                      const newSession = { id: remote.id, name: remote.title, createdAt: now(), updatedAt: now(), messages: [] };
                      state.sessions.unshift(newSession);
                      state.currentId = newSession.id;
                      save();
                      selectSession(newSession.id);
                      toast("ä¼šè¯ä¸å­˜åœ¨ï¼Œå·²åˆ›å»ºæ–°ä¼šè¯");
                      return send(content, isRetry); // é‡è¯•å‘é€
                  } catch (e) {
                      throw new Error("æ— æ³•åˆ›å»ºæ–°ä¼šè¯: " + e.message);
                  }
              }
              const errorText = await res.text();
              throw new Error(`æ¥å£å¤±è´¥ï¼š${res.status} ${res.statusText} - ${errorText}`);
          }
          const data = await res.json();
          console.log("Chat response:", data);
          handleAIResponse(tempId, data);
      } catch (err) {
          console.error("Chat error:", err.message);
          replaceThinkingWithError(tempId, err.message || "è¯·æ±‚å¤±è´¥");
      } finally {
          state.isSending = false;
          $("#btnSend").disabled = false;
          $("#spkSend").disabled = false;
      }
  };

    const handleAIResponse = (tempId, data) => {
      const s = findSession(state.currentId);
      if (!s) return;
      let text = data?.reply || data?.text;
      if (!text && Array.isArray(data?.choices) && data.choices[0]?.message?.content) text = data.choices[0].message.content;
      if (!text) text = "[åç«¯æœªè¿”å› reply å­—æ®µ]";
      const i = s.messages.findIndex(m => m.tempId === tempId);
      if (i >= 0) s.messages[i] = { role: "assistant", content: text, time: now(), audio: data.audio };
      else s.messages.push({ role: "assistant", content: text, time: now(), audio: data.audio });
      s.updatedAt = now();
      save();
      renderChat();
      if ($("#toggleSpeak").checked && !state.speakingMuted && data.audio) playAudioFromServer(data.audio);
    };

    const replaceThinkingWithError = (tempId, msg) => {
      const s = findSession(state.currentId);
      if (!s) return;
      const i = s.messages.findIndex(m => m.tempId === tempId);
      const t = `âŒ å‡ºé”™ï¼š${msg}`;
      if (i >= 0) s.messages[i] = { role: "error", content: t, time: now() };
      else s.messages.push({ role: "error", content: t, time: now() });
      s.updatedAt = now();
      save();
      renderChat();
    };

    /* ================= è¯­éŸ³æ’­æ”¾ï¼ˆåç«¯éŸ³é¢‘ï¼‰ ================= */
/* ================= è¯­éŸ³æ’­æ”¾ï¼ˆåç«¯éŸ³é¢‘ï¼‰ ================= */
const playAudioFromServer = async (audioData) => {
    if (!(await validateConversation(state.currentId))) {
        try {
            const remote = await createRemoteSession("æ–°çš„å¯¹è¯");
            state.sessions = state.sessions.filter(s => s.id !== state.currentId);
            const newSession = { id: remote.id, name: remote.title, createdAt: now(), updatedAt: now(), messages: [] };
            state.sessions.unshift(newSession);
            state.currentId = newSession.id;
            save();
            selectSession(newSession.id);
            toast("åŸä¼šè¯ä¸å­˜åœ¨ï¼Œå·²åˆ›å»ºæ–°ä¼šè¯");
        } catch (e) {
            toast("åˆ›å»ºæ–°ä¼šè¯å¤±è´¥: " + e.message);
            return;
        }
    }

    try {
        if (!audioData) {
            console.warn("No audio data provided, fetching from server...");
            const res = await fetch(`${API_ENDPOINT}/conversations/${state.currentId}/chat`, {
                method: "POST",
                headers: { "Authorization": `Bearer ${state.token}`, "Content-Type": "application/json" },
                body: JSON.stringify({ text: "Please generate audio" })
            });
            if (!res.ok) throw new Error(`éŸ³é¢‘è¯·æ±‚å¤±è´¥ï¼š${res.status}`);
            const data = await res.json();
            audioData = data.audio;
        }

        console.log("Received audio data length:", audioData.length);
        const binaryString = atob(audioData);
        const audioBytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            audioBytes[i] = binaryString.charCodeAt(i);
        }
        // éªŒè¯ WAV å¤´
        console.log("WAV header:", String.fromCharCode(...audioBytes.slice(0, 4)));
        const audioBlob = new Blob([audioBytes], { type: "audio/wav" });
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = new Audio(audioUrl);
        await audio.play().catch(err => {
            console.error("Audio play failed:", err);
            const errorBlob = new Blob([audioBytes], { type: "application/octet-stream" });
            downloadAudio(errorBlob, "debug_audio.bin");
        });
        downloadAudio(audioBlob, "reply.wav");
    } catch (e) {
        console.error("Audio playback error:", e);
        toast("éŸ³é¢‘æ’­æ”¾å¤±è´¥: " + e.message);
    }
};

function downloadAudio(blob, filename) {
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
}
    /* ================= è¯­éŸ³åˆæˆï¼ˆæœ¬åœ°å¤‡ç”¨ï¼‰ ================= */
    let voices = [];
    const synth = window.speechSynthesis;
    const loadVoices = () => {
      voices = synth.getVoices();
      const sel = $("#voiceSelect");
      sel.innerHTML = "";
      voices.forEach(v => {
        const o = document.createElement("option");
        o.value = v.name;
        o.textContent = `${v.name} (${v.lang})`;
        sel.appendChild(o);
      });
      const prefer = voices.find(v => /^zh/i.test(v.lang)) || voices.find(v => /^en/i.test(v.lang));
      if (prefer) sel.value = prefer.name;
    };
    synth.onvoiceschanged = () => loadVoices();
    const getVoice = () => voices.find(v => v.name === $("#voiceSelect").value) || voices[0];

    /* ================= äº‹ä»¶ç»‘å®š ================= */
    const bind = () => {
      $("#btnNew").addEventListener("click", async () => {
        try {
          const remote = await createRemoteSession("æ–°çš„å¯¹è¯");
          const s = { id: remote.id, name: remote.title, createdAt: now(), updatedAt: now(), messages: [] };
          state.sessions.unshift(s);
          save();
          selectSession(s.id);
        } catch (e) {
          toast("æ–°å»ºå¯¹è¯å¤±è´¥: " + e.message);
        }
      });
      $("#btnExport").addEventListener("click", () => {
        const blob = new Blob([JSON.stringify(state.sessions, null, 2)], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `ai_sessions_${new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-')}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
      });
      $("#btnClearAll").addEventListener("click", () => {
        if (confirm("ç¡®è®¤æ¸…ç©ºæ‰€æœ‰ä¼šè¯ï¼Ÿ")) {
          state.sessions = [];
          save();
          $("#btnNew").click();
        }
      });
      $("#searchInput").addEventListener("input", renderHistory);
      $("#convTitle").addEventListener("input", (e) => renameCurrent(e.target.value));
      $("#btnSend").addEventListener("click", () => send());
      $("#input").addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          send();
        }
      });
      $("#btnStopSpeak").addEventListener("click", () => {
        const audio = document.querySelector("audio");
        if (audio) audio.pause();
      });
      $("#btnMute").addEventListener("click", () => {
        state.speakingMuted = !state.speakingMuted;
        $("#btnMute").textContent = state.speakingMuted ? "æ¢å¤" : "é™éŸ³";
        toast(state.speakingMuted ? "å·²é™éŸ³" : "å·²æ¢å¤æ’­æŠ¥");
      });
      $("#btnReloadVoices").addEventListener("click", loadVoices);
      $("#spkSend").addEventListener("click", () => {
        if (state.isSending) {
          toast("æ­£åœ¨å‘é€ï¼Œè¯·ç¨å€™");
          return;
        }
        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = "audio/*";
        fileInput.onchange = (e) => {
          $("#spkSend").files = e.target.files;
          send();
        };
        fileInput.click();
      });
      $("#chat").addEventListener("dblclick", () => {
        const s = findSession(state.currentId);
        if (!s) return;
        const lastAI = [...s.messages].reverse().find(m => m.role === "assistant");
        if (lastAI && lastAI.audio) playAudioFromServer(lastAI.audio);
      });
      $("#btnLogout").addEventListener("click", () => {
        localStorage.removeItem('token');
        localStorage.removeItem('username');
        state.token = null;
        state.username = null;
        $("#username").textContent = "æœªç™»å½•";
        showModal();
        toast("å·²æ³¨é”€");
      });
      $("#loginBtn").addEventListener("click", login);
      $("#registerBtn").addEventListener("click", register);
    };

    /* ================= ç™»å½•/æ³¨å†Œ ================= */
    function showModal() {
      $("#loginModal").style.display = "block";
    }
    async function register() {
      if (state.isLoggingIn) {
        toast("æ­£åœ¨æ³¨å†Œï¼Œè¯·ç¨å€™");
        return;
      }
      state.isLoggingIn = true;
      $("#registerBtn").disabled = true;
      const username = $("#loginUsername").value;
      const password = $("#password").value;
      const byteLength = new TextEncoder().encode(password).length;
      console.log("Register attempt:", { username, password, byteLength, passwordChars: password.split('') });
      if (byteLength > 72) {
        toast("å¯†ç é•¿åº¦ä¸èƒ½è¶…è¿‡72å­—èŠ‚");
        state.isLoggingIn = false;
        $("#registerBtn").disabled = false;
        return;
      }
      try {
        const res = await fetch(`${API_ENDPOINT}/register`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ username, password })
        });
        if (res.ok) {
          toast("æ³¨å†ŒæˆåŠŸï¼Œè¯·ç™»å½•");
        } else {
          const errorText = await res.text();
          console.error("Register failed:", errorText);
          toast("æ³¨å†Œå¤±è´¥: " + errorText);
        }
      } catch (err) {
        console.error("Register error:", err.message);
        toast("æ³¨å†Œå¤±è´¥: ç½‘ç»œé”™è¯¯");
      } finally {
        state.isLoggingIn = false;
        $("#registerBtn").disabled = false;
      }
    }
    async function login() {
      if (state.isLoggingIn) {
        toast("æ­£åœ¨ç™»å½•ï¼Œè¯·ç¨å€™");
        return;
      }
      state.isLoggingIn = true;
      $("#loginBtn").disabled = true;
      const username = $("#loginUsername").value;
      const password = $("#password").value;
      console.log("Login attempt:", { username });
      try {
        const res = await fetch(`${API_ENDPOINT}/token`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ username, password })
        });
        if (res.ok) {
          const data = await res.json();
          state.token = data.access_token;
          state.username = username;
          localStorage.setItem('token', state.token);
          localStorage.setItem('username', username);
          $("#username").textContent = username;
          console.log("Login successful, username set:", username);
          closeModal();
          toast("ç™»å½•æˆåŠŸ");
          await syncConversations();
          if (!state.sessions.length || !state.currentId) {
            try {
              const remote = await createRemoteSession("æ–°çš„å¯¹è¯");
              const s = { id: remote.id, name: remote.title, createdAt: now(), updatedAt: now(), messages: [] };
              state.sessions.unshift(s);
              s.messages.push({ role: "assistant", content: "ä½ å¥½ï¼Œæˆ‘æ˜¯ä½ çš„ AI å¯¼å¸ˆã€‚æœ‰ä»€ä¹ˆæƒ³èŠçš„ï¼Ÿ", time: now() });
              save();
              selectSession(s.id);
            } catch (e) {
              toast("åˆå§‹åŒ–ä¼šè¯å¤±è´¥: " + e.message);
              const s = { id: "s_fallback", name: "æ–°çš„å¯¹è¯", createdAt: now(), updatedAt: now(), messages: [] };
              state.sessions.unshift(s);
              save();
              selectSession(s.id);
            }
          } else {
            selectSession(state.currentId || state.sessions[0].id);
          }
          renderHistory();
        } else {
          const errorText = await res.text();
          console.error("Login failed:", errorText);
          toast("ç™»å½•å¤±è´¥: " + errorText);
        }
      } catch (err) {
        console.error("Login error:", err.message);
        toast("ç™»å½•å¤±è´¥: ç½‘ç»œé”™è¯¯");
      } finally {
        state.isLoggingIn = false;
        $("#loginBtn").disabled = false;
      }
    }
    function closeModal() {
      $("#loginModal").style.display = "none";
    }

    /* ================= å¯åŠ¨ ================= */
    (async function init() {
      bind();
      loadVoices();
      try { state.sessions = JSON.parse(localStorage.getItem(storeKey) || "[]"); } catch { state.sessions = []; }
      if (state.username) {
        $("#username").textContent = state.username;
        console.log("Restored username from localStorage:", state.username);
      }
      if (!state.token || !(await validateToken(state.token))) {
        localStorage.removeItem('token');
        localStorage.removeItem('username');
        state.token = null;
        state.username = null;
        $("#username").textContent = "æœªç™»å½•";
        showModal();
        return;
      }
      await syncConversations();
      if (!state.sessions.length || !state.currentId) {
        try {
          const remote = await createRemoteSession("æ–°çš„å¯¹è¯");
          const s = { id: remote.id, name: remote.title, createdAt: now(), updatedAt: now(), messages: [] };
          state.sessions.unshift(s);
          s.messages.push({ role: "assistant", content: "ä½ å¥½ï¼Œæˆ‘æ˜¯ä½ çš„ AI å¯¼å¸ˆã€‚æœ‰ä»€ä¹ˆæƒ³èŠçš„ï¼Ÿ", time: now() });
          save();
          selectSession(s.id);
        } catch (e) {
          toast("åˆå§‹åŒ–ä¼šè¯å¤±è´¥: " + e.message);
          const s = { id: "s_fallback", name: "æ–°çš„å¯¹è¯", createdAt: now(), updatedAt: now(), messages: [] };
          state.sessions.unshift(s);
          save();
          selectSession(s.id);
        }
      } else {
        selectSession(state.currentId || state.sessions[0].id);
      }
      renderHistory();
    })();
  </script>
</body>
</html>